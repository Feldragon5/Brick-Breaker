<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, user-scalable=no"
		/>
		<title>Vertical Brick Slayer (Dark)</title>
		<style>
			body {
				margin: 0;
				padding: 0;
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				background-color: #121212;
				font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
				color: #e0e0e0;
				overflow: hidden;
			}
			canvas {
				border: 1px solid #444;
				background-color: #1e1e1e;
				display: block;
				max-width: 100%;
				max-height: 100vh;
			}
		</style>
	</head>
	<body>
		<canvas id="gameCanvas" width="400" height="700"></canvas>

		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");

			// --- Game Constants ---
			const PADDLE_HEIGHT = 12;
			const PADDLE_WIDTH = 90;
			const BALL_RADIUS = 7;
			const BRICK_ROW_COUNT = 10;
			const BRICK_COLUMN_COUNT = 7;
			const BRICK_WIDTH = 45;
			const BRICK_HEIGHT = 20;
			const BRICK_PADDING = 4;
			const BRICK_OFFSET_TOP = 50;
			const BRICK_OFFSET_LEFT =
				(canvas.width -
					(BRICK_COLUMN_COUNT * (BRICK_WIDTH + BRICK_PADDING) -
						BRICK_PADDING)) /
				2;

			const PADDLE_SPEED = 9;
			const INITIAL_BALL_SPEED_X = 4;
			const INITIAL_BALL_SPEED_Y = -5; // Start upwards

			const PARTICLE_COUNT = 15; // More particles again
			const PARTICLE_LIFE = 35; // Slightly longer life
			const PARTICLE_SPEED_FACTOR = 2.5; // Faster burst
			const PARTICLE_SIZE = 2.5; // Slightly larger

			// --- Dark Theme Colors ---
			const BG_COLOR = "#1e1e1e";
			const PADDLE_COLOR = "#bdc3c7";
			const BALL_COLOR = "#ffffff";
			const TEXT_COLOR = "#e0e0e0";
			const INFO_TEXT_COLOR = "#888888";
			const GAMEOVER_COLOR = "#e74c3c";
			const GAMEWON_COLOR = "#2ecc71"; // Green for win
			const availableColors = [
				"#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6",
				"#1abc9c", "#e67e22", "#34ace0", "#ff7f50", "#ff6b81",
			];

			// --- Game State Variables ---
			let ball = {};
			let paddle = {};
			let bricks = [];
			let particles = [];
			let score = 0;
			let lives = 3;
			let isGameOver = false;
			let isGameWon = false;
			let animationFrameId;
			let rightPressed = false;
			let leftPressed = false;

			// --- Initialization ---
			function initGame() {
				score = 0;
				lives = 3;
				isGameOver = false;
				isGameWon = false;
				particles = []; // Clear particles on restart
				rightPressed = false;
				leftPressed = false;

				ball = {
					x: canvas.width / 2,
					y: canvas.height - 80, // Start a bit above paddle area
					dx: INITIAL_BALL_SPEED_X * (Math.random() < 0.5 ? 1 : -1),
					dy: INITIAL_BALL_SPEED_Y,
					radius: BALL_RADIUS,
					color: BALL_COLOR,
				};

                // Set paddle initial position only if it's the very first init
                if (paddle.x === undefined) {
				    paddle.x = (canvas.width - PADDLE_WIDTH) / 2;
                }
                // Always reset Y position and properties
				paddle.y = canvas.height - PADDLE_HEIGHT - 20;
				paddle.width = PADDLE_WIDTH;
				paddle.height = PADDLE_HEIGHT;
				paddle.color = PADDLE_COLOR;

				// Bricks setup
				bricks = [];
				for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
					bricks[c] = [];
					for (let r = 0; r < BRICK_ROW_COUNT; r++) {
						const brickX =
							c * (BRICK_WIDTH + BRICK_PADDING) +
							BRICK_OFFSET_LEFT;
						const brickY =
							r * (BRICK_HEIGHT + BRICK_PADDING) +
							BRICK_OFFSET_TOP;
						bricks[c][r] = {
							x: brickX,
							y: brickY,
							width: BRICK_WIDTH,
							height: BRICK_HEIGHT,
							status: 1, // 1: active, 0: broken
							color: availableColors[
								Math.floor(
									Math.random() * availableColors.length
								)
							],
						};
					}
				}

				// Ensure the game loop starts if it was stopped by game over/win
				if (!animationFrameId || isGameOver || isGameWon) {
					if (animationFrameId) cancelAnimationFrame(animationFrameId); // Stop previous loop if any
					gameLoop();
				}
			}

			// --- Drawing Functions ---
			function drawBall() {
				ctx.beginPath();
				ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
				ctx.fillStyle = ball.color;
				ctx.fill();
				ctx.closePath();
			}

			function drawPaddle() {
				if (paddle.x === undefined) return; // Don't draw before initialized
				// Draw rounded paddle
				ctx.beginPath();
                ctx.lineCap = "round";
				ctx.lineWidth = paddle.height;
				ctx.moveTo(paddle.x + paddle.height / 2, paddle.y + paddle.height / 2);
				ctx.lineTo(paddle.x + paddle.width - paddle.height / 2, paddle.y + paddle.height / 2);
				ctx.strokeStyle = paddle.color;
				ctx.stroke();
				ctx.closePath();
			}

			function drawBricks() {
				for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
					for (let r = 0; r < BRICK_ROW_COUNT; r++) {
						if (bricks[c][r].status === 1) {
							const brick = bricks[c][r];
							ctx.beginPath();
							ctx.rect(
								brick.x,
								brick.y,
								brick.width,
								brick.height
							);
							ctx.fillStyle = brick.color;
							ctx.fill();
							ctx.closePath();
                            // Optional: subtle border for definition
							ctx.strokeStyle = "rgba(0, 0, 0, 0.2)";
							ctx.lineWidth = 1;
							ctx.strokeRect(
								brick.x,
								brick.y,
								brick.width,
								brick.height
							);
						}
					}
				}
			}

			function drawScore() {
				ctx.font = '18px "Segoe UI", sans-serif';
				ctx.fillStyle = TEXT_COLOR;
				ctx.fillText("Score: " + score, 15, 30);
			}

			function drawLives() {
				ctx.font = '18px "Segoe UI", sans-serif';
				ctx.fillStyle = TEXT_COLOR;
				ctx.fillText("Lives: " + lives, canvas.width - 80, 30);
			}

			function drawParticles() {
				particles.forEach((p, index) => { // Added index for potential splice later if needed
					ctx.beginPath();
					ctx.rect(
						p.x - p.size / 2,
						p.y - p.size / 2,
						p.size,
						p.size
					);
					ctx.fillStyle = p.color;
					ctx.globalAlpha = Math.max(0, p.life / PARTICLE_LIFE); // Fade out
					ctx.fill();
					ctx.closePath();
				});
				ctx.globalAlpha = 1.0; // Reset global alpha
			}

			function drawMessage(message, color) {
				ctx.font = 'bold 32px "Segoe UI", sans-serif';
				ctx.fillStyle = color;
				ctx.textAlign = "center";
				ctx.fillText(message, canvas.width / 2, canvas.height / 2 - 40);

				ctx.font = '18px "Segoe UI", sans-serif';
				ctx.fillStyle = INFO_TEXT_COLOR;
				ctx.fillText(
					"Press SPACE to Restart",
					canvas.width / 2,
					canvas.height / 2
				);
				ctx.textAlign = "left"; // Reset alignment
			}

			// --- Update & Collision Logic ---

            function updatePaddle() {
                // Paddle movement should only happen if game is active
                if (isGameOver || isGameWon) return;

                if (leftPressed) {
                    paddle.x -= PADDLE_SPEED;
                } else if (rightPressed) {
                    paddle.x += PADDLE_SPEED;
                }
                // Keep paddle within bounds
                paddle.x = Math.max(
                    0,
                    Math.min(paddle.x, canvas.width - paddle.width)
                );
            }

            function updateBall() {
                // Don't update ball if game is over or won
                if (isGameOver || isGameWon) return;

                // Calculate next potential position
                let nextX = ball.x + ball.dx;
                let nextY = ball.y + ball.dy;

                // --- Wall collisions (left/right/top) ---
                if (nextX > canvas.width - ball.radius || nextX < ball.radius) {
                    ball.dx = -ball.dx;
                    // Adjust position slightly to prevent sticking
                    if (nextX > canvas.width - ball.radius) ball.x = canvas.width - ball.radius;
                    if (nextX < ball.radius) ball.x = ball.radius;
                    // Recalculate nextX after bounce if necessary for subsequent checks
                    nextX = ball.x + ball.dx;
                }
                if (nextY < ball.radius) {
                    ball.dy = -ball.dy;
                    // Adjust position slightly
                    if (nextY < ball.radius) ball.y = ball.radius;
                    // Recalculate nextY
                    nextY = ball.y + ball.dy;
                }

                // --- Paddle Collision Check ---
                // Check specifically if the ball is moving downwards AND will intersect the paddle area
                // Note: We check the *next* position (nextY) against the paddle's top edge.
                else if (ball.dy > 0 && // Must be moving downwards
                         nextY + ball.radius > paddle.y && // Ball's next bottom edge will be below paddle's top edge
                         ball.y + ball.radius <= paddle.y && // Ball's *current* bottom edge is at or above paddle top (prevents collision if starting inside)
                         nextX + ball.radius > paddle.x && // Ball's next horizontal position overlaps paddle
                         nextX - ball.radius < paddle.x + paddle.width) // Ball's next horizontal position overlaps paddle
                 {
                    paddleCollision(); // Handle the bounce logic (reverses dy, adjusts dx, corrects y)
                    // After paddleCollision, dy is negative, dx might change, y is corrected.
                    // The position update at the end will handle the actual move away from the paddle.
                 }

                // --- Bottom Edge / Life Loss Check ---
                // This check now happens *only if* the paddle collision didn't occur.
                else if (nextY > canvas.height - ball.radius) {
                    lives--;
                    if (lives <= 0) {
                        isGameOver = true;
                        // Stop ball for game over screen
                        ball.dx = 0;
                        ball.dy = 0;
                        ball.x = canvas.width / 2;
                        ball.y = canvas.height / 2 + 50;
                        // No further position update needed this frame
                        return; // Exit early as the game is over
                    } else {
                        // Reset ball position for the next life
                        ball.x = canvas.width / 2;
                        ball.y = canvas.height - 80; // Reset higher up
                        ball.dx = INITIAL_BALL_SPEED_X * (Math.random() < 0.5 ? 1 : -1);
                        ball.dy = INITIAL_BALL_SPEED_Y; // Reset speed upwards
                        // No further position update needed this frame
                        return; // Exit early as the ball position is reset
                    }
                }

                // --- Update ball position ---
                // This happens if no wall bounce, no paddle bounce, and no life loss occurred.
                ball.x += ball.dx;
                ball.y += ball.dy;
            }


            function paddleCollision() {
                 // We know ball.dy > 0 because of the check in updateBall
                ball.dy = -ball.dy; // Reverse vertical direction

                // Calculate where the ball hit the paddle relative to the paddle center
                let collidePoint = ball.x - (paddle.x + paddle.width / 2);

                // Adjust horizontal speed based on collision point
                // A larger multiplier makes the angle more sensitive to hit location
                ball.dx = collidePoint * 0.15;

                // Clamp the horizontal speed to prevent extreme angles
                const maxPaddleBounceDx = Math.abs(INITIAL_BALL_SPEED_X) * 2.2;
                ball.dx = Math.max(-maxPaddleBounceDx, Math.min(maxPaddleBounceDx, ball.dx));

                 // --- Crucial Correction ---
                 // Place the ball slightly above the paddle to prevent it from getting stuck
                 // or triggering collision again immediately in the next frame.
                 ball.y = paddle.y - ball.radius - 0.1;
            }

			function brickCollision() {
                // Don't check collisions if game over/won
                 if (isGameOver || isGameWon) return;

				// No need to cache totalBricks if checking status directly for win condition

				for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
					for (let r = 0; r < BRICK_ROW_COUNT; r++) {
						const brick = bricks[c][r];
						if (brick.status === 1) {
                            // Simple center-point collision check for pass-through effect
							if (
								ball.x > brick.x &&
								ball.x < brick.x + brick.width &&
								ball.y > brick.y &&
								ball.y < brick.y + brick.height
							) {
								brick.status = 0;
								score++;
								createShatterEffect(
									brick.x + brick.width / 2,
									brick.y + brick.height / 2,
									brick.color
								);

								// Check for win condition by counting remaining bricks
                                let remainingBricks = 0;
                                for (let cc = 0; cc < BRICK_COLUMN_COUNT; cc++) {
                                    for (let rr = 0; rr < BRICK_ROW_COUNT; rr++) {
                                        if (bricks[cc][rr].status === 1) {
                                            remainingBricks++;
                                        }
                                    }
                                }

                                if (remainingBricks === 0) {
                                    isGameWon = true;
                                    ball.dx = 0; // Stop ball
                                    ball.dy = 0;
                                    ball.x = canvas.width / 2; // Center for win screen
                                    ball.y = canvas.height / 2 + 50;
                                    return; // Exit function early, game won
                                }
							}
						}
					}
				}
			}

			function createShatterEffect(x, y, color) {
				for (let i = 0; i < PARTICLE_COUNT; i++) {
					particles.push({
						x: x,
						y: y,
						dx: (Math.random() - 0.5) * PARTICLE_SPEED_FACTOR * 2,
						dy: (Math.random() - 0.5) * PARTICLE_SPEED_FACTOR * 2,
						life: PARTICLE_LIFE + Math.random() * 10, // Vary life slightly
						color: color,
						size: PARTICLE_SIZE + Math.random() * 1, // Vary size slightly
					});
				}
			}

			function updateParticles() {
				for (let i = particles.length - 1; i >= 0; i--) {
					const p = particles[i];
					p.x += p.dx;
					p.y += p.dy;
					p.dy += 0.06; // Simple gravity
					p.life--;

					// Remove particle if life is up
					if (p.life <= 0) {
						particles.splice(i, 1);
					}
				}
			}

			// --- Input Handlers ---

			function keyDownHandler(e) {
				// --- Spacebar Restart ---
				if (
					(e.code === "Space" || e.key === " ") &&
					(isGameOver || isGameWon)
				) {
                    // Reset game state and restart
                    // Stop the current animation loop before starting a new one in initGame
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null; // Clear the ID
                    }
					initGame();
					e.preventDefault(); // Prevent spacebar from scrolling page
					return; // Stop processing other keys if restarting
				}

				// --- Paddle Movement (only when game is active) ---
				if (!isGameOver && !isGameWon) {
					if (
						e.key === "Right" ||
						e.key === "ArrowRight" ||
						e.key === "d" ||
						e.key === "D"
					) {
						rightPressed = true;
					} else if (
						e.key === "Left" ||
						e.key === "ArrowLeft" ||
						e.key === "a" ||
						e.key === "A"
					) {
						leftPressed = true;
					}
				}

				// Prevent default action for game control keys to avoid scrolling etc.
				if (
					[
						"ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown",
                        " ", "a", "A", "d", "D"
					].includes(e.key)
				) {
					e.preventDefault();
				}
			}

			function keyUpHandler(e) {
				if (
					e.key === "Right" ||
					e.key === "ArrowRight" ||
					e.key === "d" ||
					e.key === "D"
				) {
					rightPressed = false;
				} else if (
					e.key === "Left" ||
					e.key === "ArrowLeft" ||
					e.key === "a" ||
					e.key === "A"
				) {
					leftPressed = false;
				}
			}

			// --- Event Listeners Setup ---
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);
            // Touch controls could be added here for mobile


			// --- Game Loop ---
			function gameLoop() {
				// Clear canvas
				ctx.fillStyle = BG_COLOR;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Update game state first
				updatePaddle();   // Updates paddle position based on input (if active)
				updateBall();     // Updates ball position, handles wall/paddle/bottom (if active)
				brickCollision(); // Checks for brick hits & win condition (if active)
                updateParticles();// Always update particles for visual effects

				// Draw elements (Order matters for layering)
				drawBricks();
				drawPaddle();
				drawBall();
				drawParticles(); // Draw particles after main game elements but before UI text
				drawScore();
				drawLives();

                // Draw Game Over / Win Messages last, on top of everything
				if (isGameOver) {
					drawMessage("GAME OVER", GAMEOVER_COLOR);
                    // Stop the loop if game is over
					// animationFrameId = null; // Option 1: Stop loop here
                    // return;
				} else if (isGameWon) {
					drawMessage("YOU WIN!", GAMEWON_COLOR);
                     // Stop the loop if game is won
					// animationFrameId = null; // Option 1: Stop loop here
                    // return;
				}

                // Request next frame (only if game is not definitively stopped)
                // If you uncomment the returns above, this line won't be reached on game over/win
				animationFrameId = requestAnimationFrame(gameLoop);
                // Option 2: Always request frame, rely on checks within update functions
                // This allows particles to keep animating on end screens.
			}

			// --- Start Game ---
			initGame(); // Set up initial state
			// gameLoop() is called by initGame the first time and on restarts
		</script>
	</body>
</html>