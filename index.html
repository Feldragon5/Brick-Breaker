<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, user-scalable=no"
		/>
		<title>Infinite Vertical Brick Slayer</title>
		<style>
			body {
				margin: 0; padding: 0; display: flex; justify-content: center; align-items: center;
				height: 100vh; background-color: #121212; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
				color: #e0e0e0; overflow: hidden;
			}
			canvas {
				border: 1px solid #444; background-color: #1e1e1e; display: block;
				max-width: 100%; max-height: 100vh;
                /* Ensure touches on the canvas are handled by our script */
                touch-action: none;
			}
			.debug-text {
				position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
				color: yellow; font-size: 14px; background-color: rgba(0, 0, 0, 0.5);
				padding: 2px 5px; border-radius: 3px; z-index: 10; text-align: center;
			}
		</style>
	</head>
	<body>
		<div id="debugIndicator" class="debug-text" style="display: none;">
            DEBUG MODE ACTIVE<br>(5x Speed / Bottom Bounce)<br>Press T to toggle
        </div>
		<canvas id="gameCanvas" width="400" height="700"></canvas>

		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");
			const debugIndicator = document.getElementById("debugIndicator");

			// --- Game Constants ---
			const PADDLE_HEIGHT = 12;
			const PADDLE_WIDTH = 90;
			const BALL_RADIUS = 7;
			const BRICK_ROW_COUNT = 15;
			const BRICK_COLUMN_COUNT = 7;
			const BRICK_WIDTH = 45;
			const BRICK_HEIGHT = 20;
			const BRICK_PADDING = 4;
			const BRICK_OFFSET_TOP = 50;
			const BRICK_OFFSET_LEFT = (canvas.width - (BRICK_COLUMN_COUNT * (BRICK_WIDTH + BRICK_PADDING) - BRICK_PADDING)) / 2;
			const ROW_HEIGHT = BRICK_HEIGHT + BRICK_PADDING;

			const PADDLE_SPEED = 9;
			const INITIAL_BALL_SPEED_X = 4;
			const INITIAL_BALL_SPEED_Y = -5; // Base speed

			const PARTICLE_COUNT = 15;
			const PARTICLE_LIFE = 35;
			const PARTICLE_SPEED_FACTOR = 2.5;
			const PARTICLE_SIZE = 2.5;

			const LAUNCH_DELAY_FRAMES = 60; // Approx 1 second at 60fps

            // --- Animation Constants ---
            const ROW_ANIMATION_SPEED = 8; // <-- Increased animation speed
            const SCORE_FOR_EXTRA_LIFE = 50; // Points needed for an extra life

			// --- Dark Theme Colors ---
			const BG_COLOR = "#1e1e1e"; const PADDLE_COLOR = "#bdc3c7"; const BALL_COLOR = "#ffffff";
			const TEXT_COLOR = "#e0e0e0"; const INFO_TEXT_COLOR = "#888888"; const GAMEOVER_COLOR = "#e74c3c";
            const PAUSE_COLOR = "#3498db";
			const availableColors = [ "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6", "#1abc9c", "#e67e22", "#34ace0", "#ff7f50", "#ff6b81"];

			// --- Game State Variables ---
			let ball = {}; let paddle = {}; let bricks = []; let particles = [];
			let score = 0; // Counts bricks
            let lives = 3; let isGameOver = false;
			let animationFrameId; let rightPressed = false; let leftPressed = false;
			let rowsAdvanced = 0; // Still useful for tracking game progression/difficulty maybe

            let isPaused = false; let waitingToLaunch = true; let launchDelayTimer = 0;

            // --- Debug State ---
            let isDebugMode = false;
            let debugSpeedMultiplier = 1; // 1 for normal speed, 5 for debug

            // --- Animation State ---
            let isAnimatingRows = false; // Is the row shift animation playing?
            let animationTargetY = 0;   // Total Y distance to shift
            let animationCurrentY = 0;  // Current Y offset during animation
            let rowsToShiftAmount = 0;  // How many rows need to be generated after animation


			// --- Initialization ---
			function initGame() {
				score = 0; // Reset brick score
                rowsAdvanced = 0; // Reset row counter
                lives = 3; isGameOver = false; isPaused = false;
				// isDebugMode persists across restarts unless toggled off
                debugSpeedMultiplier = isDebugMode ? 5 : 1; // Ensure multiplier matches state on restart
				particles = []; rightPressed = false; leftPressed = false;
                isAnimatingRows = false; // Reset animation state
                animationTargetY = 0; animationCurrentY = 0; rowsToShiftAmount = 0;

                resetBallForLaunch();

				if (paddle.x === undefined) paddle.x = (canvas.width - PADDLE_WIDTH) / 2;
				paddle.y = canvas.height - PADDLE_HEIGHT - 20;
				paddle.width = PADDLE_WIDTH; paddle.height = PADDLE_HEIGHT; paddle.color = PADDLE_COLOR;

				bricks = [];
				for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
					bricks[c] = [];
					for (let r = 0; r < BRICK_ROW_COUNT; r++) {
						bricks[c][r] = createBrick(c, r);
					}
				}

				if (!animationFrameId || isGameOver) {
					if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
					gameLoop();
				}
                // Ensure debug indicator visibility matches state
                debugIndicator.style.display = isDebugMode ? 'block' : 'none';
			}

            function resetBallForLaunch(keepCurrentPos = false) {
                 if (!keepCurrentPos) { ball.x = canvas.width / 2; ball.y = canvas.height - 80; }
                 ball.dx = 0; // Base speed dx (will be multiplied later if debug)
                 ball.dy = 0; // Base speed dy (will be multiplied later if debug)
                 ball.radius = BALL_RADIUS; ball.color = BALL_COLOR;
                 waitingToLaunch = true; launchDelayTimer = LAUNCH_DELAY_FRAMES;
            }
            function createBrick(c, r) {
                const brickX = c * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT;
                const brickY = r * ROW_HEIGHT + BRICK_OFFSET_TOP;
                const colorIndex = Math.floor(Math.random() * availableColors.length);
                return { x: brickX, y: brickY, width: BRICK_WIDTH, height: BRICK_HEIGHT, status: 1, color: availableColors[colorIndex] };
            }

			// --- Drawing Functions ---
			function drawBall() { /* ... no changes ... */
				ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fillStyle = ball.color; ctx.fill(); ctx.closePath(); }
			function drawPaddle() { /* ... no changes ... */
				if (paddle.x === undefined) return;
				ctx.beginPath(); ctx.lineCap = "round"; ctx.lineWidth = paddle.height;
				ctx.moveTo(paddle.x + paddle.height / 2, paddle.y + paddle.height / 2);
				ctx.lineTo(paddle.x + paddle.width - paddle.height / 2, paddle.y + paddle.height / 2);
				ctx.strokeStyle = paddle.color; ctx.stroke(); ctx.closePath(); }

			function drawBricks() { /* ... no changes ... */
                const yOffset = isAnimatingRows ? animationCurrentY : 0;
				for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
					for (let r = 0; r < BRICK_ROW_COUNT; r++) {
						if (bricks[c] && bricks[c][r] && bricks[c][r].status === 1) {
							const brick = bricks[c][r];
							ctx.beginPath();
							ctx.rect( brick.x, brick.y + yOffset, brick.width, brick.height );
							ctx.fillStyle = brick.color; ctx.fill(); ctx.closePath();
							ctx.strokeStyle = "rgba(0, 0, 0, 0.2)"; ctx.lineWidth = 1;
							ctx.strokeRect(brick.x, brick.y + yOffset, brick.width, brick.height);
						}
					}
				}
			}
			function drawScore() { /* ... no changes ... */
				ctx.font = '18px "Segoe UI", sans-serif'; ctx.fillStyle = TEXT_COLOR; ctx.fillText("Score: " + score, 15, 30); }
			function drawLives() { /* ... no changes ... */
				ctx.font = '18px "Segoe UI", sans-serif'; ctx.fillStyle = TEXT_COLOR; ctx.fillText("Lives: " + lives, canvas.width - 80, 30); }
			function drawParticles() { /* ... no changes ... */
				particles.forEach((p) => {
					ctx.beginPath(); ctx.rect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
					ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life / PARTICLE_LIFE);
					ctx.fill(); ctx.closePath();
				});
				ctx.globalAlpha = 1.0; }
			function drawMessage(message, color) { /* ... no changes ... */
				ctx.font = 'bold 32px "Segoe UI", sans-serif'; ctx.fillStyle = color; ctx.textAlign = "center";
				ctx.fillText(message, canvas.width / 2, canvas.height / 2 - 40);
				ctx.font = '18px "Segoe UI", sans-serif'; ctx.fillStyle = INFO_TEXT_COLOR;
				ctx.fillText("Press SPACE or Tap Screen to Restart", canvas.width / 2, canvas.height / 2);
				ctx.textAlign = "left"; }
            function drawPauseMessage() { /* ... no changes ... */
                ctx.font = 'bold 36px "Segoe UI", sans-serif'; ctx.fillStyle = PAUSE_COLOR; ctx.textAlign = "center";
				ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2 - 40);
				ctx.font = '20px "Segoe UI", sans-serif'; ctx.fillStyle = INFO_TEXT_COLOR;
				ctx.fillText("Press ESC to Resume", canvas.width / 2, canvas.height / 2);
				ctx.textAlign = "left"; }

			// --- Update & Collision Logic ---

            function updatePaddle() { /* ... no changes ... */
                if (isPaused || isGameOver || isAnimatingRows) return;
                if (leftPressed) paddle.x -= PADDLE_SPEED;
                else if (rightPressed) paddle.x += PADDLE_SPEED;
                paddle.x = Math.max(0, Math.min(paddle.x, canvas.width - paddle.width));
            }

            function updateLaunchDelay() { /* ... no changes ... */
                if (waitingToLaunch && !isPaused && !isGameOver && !isAnimatingRows) {
                    launchDelayTimer--;
                    if (launchDelayTimer <= 0) {
                        waitingToLaunch = false;
                        ball.dx = INITIAL_BALL_SPEED_X * (Math.random() < 0.5 ? 1 : -1);
                        ball.dy = INITIAL_BALL_SPEED_Y;
                    }
                }
            }

            function updateBall() { /* ... no changes ... */
                if (isPaused || isGameOver || waitingToLaunch || isAnimatingRows) return;
                let nextX = ball.x + ball.dx * debugSpeedMultiplier;
                let nextY = ball.y + ball.dy * debugSpeedMultiplier;
                // Wall collisions (Bounce)
                if (nextX > canvas.width - ball.radius || nextX < ball.radius) {
                    ball.dx = -ball.dx;
                    if (nextX > canvas.width - ball.radius) ball.x = canvas.width - ball.radius;
                    if (nextX < ball.radius) ball.x = ball.radius;
                    nextX = ball.x + ball.dx * debugSpeedMultiplier;
                }
                // Top wall collision (Bounce)
                if (nextY < ball.radius) {
                    ball.dy = -ball.dy;
                    if (nextY < ball.radius) ball.y = ball.radius;
                    nextY = ball.y + ball.dy * debugSpeedMultiplier;
                }
                // Paddle Collision (Bounce)
                else if (ball.dy > 0 && nextY + ball.radius > paddle.y && ball.y + ball.radius <= paddle.y && nextX + ball.radius > paddle.x && nextX - ball.radius < paddle.x + paddle.width) {
                    paddleCollision();
                    nextY = ball.y + ball.dy * debugSpeedMultiplier; // Recalculate nextY after bounce
                }
                // Bottom Edge / Life Loss / Debug Bounce
                else if (nextY > canvas.height - ball.radius) {
                    if (isDebugMode) {
                        ball.dy = -ball.dy; // Bounce
                        ball.y = canvas.height - ball.radius;
                    } else {
                        lives--; // Lose life
                        if (lives <= 0) {
                            isGameOver = true; ball.dx = 0; ball.dy = 0;
                            ball.x = canvas.width / 2; ball.y = canvas.height / 2 + 50;
                            return;
                        } else {
                            resetBallForLaunch(); return;
                        }
                    }
                }
                // Update position
                ball.x += ball.dx * debugSpeedMultiplier;
                ball.y += ball.dy * debugSpeedMultiplier;
            }

            function paddleCollision() { /* ... no changes ... */
                if (ball.dy <= 0) return;
                ball.dy = -ball.dy;
                let collidePoint = ball.x - (paddle.x + paddle.width / 2);
                ball.dx = collidePoint * 0.15;
                const maxPaddleBounceDx = Math.abs(INITIAL_BALL_SPEED_X) * 2.2;
                ball.dx = Math.max(-maxPaddleBounceDx, Math.min(maxPaddleBounceDx, ball.dx));
                ball.y = paddle.y - ball.radius - 0.1;
             }

			function brickCollision() {
                 if (isPaused || isGameOver || waitingToLaunch || isAnimatingRows) return false;
                 let collisionOccurred = false;
                 const yOffset = isAnimatingRows ? animationCurrentY : 0;

				 for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
					for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                        if (bricks[c] && bricks[c][r] && bricks[c][r].status === 1) {
                            const brick = bricks[c][r];
                            const brickTop = brick.y + yOffset;
                            const brickBottom = brick.y + brick.height + yOffset;
                            const brickLeft = brick.x;
                            const brickRight = brick.x + brick.width;

                            // AABB collision check
							if ( ball.x + ball.radius > brickLeft &&
                                 ball.x - ball.radius < brickRight &&
                                 ball.y + ball.radius > brickTop &&
                                 ball.y - ball.radius < brickBottom )
                            {
								brick.status = 0;
                                score++; // Increment score

                                // --- Add Extra Life Check ---
                                if (score > 0 && score % SCORE_FOR_EXTRA_LIFE === 0) {
                                    lives++;
                                    // Optional: Add visual/audio feedback for extra life
                                    console.log(`Extra life awarded! Score: ${score}, Lives: ${lives}`);
                                }
                                // --------------------------

                                createShatterEffect(brick.x + brick.width / 2, brick.y + brick.height / 2 + yOffset, brick.color);
                                collisionOccurred = true;
                                // Ball passes through - no bounce logic here
							}
						}
					}
				}
                return collisionOccurred;
			}

            function checkAndShiftRows() { /* ... no changes ... */
                if (isPaused || isGameOver || isAnimatingRows) return;
                let lowestActiveRow = -1;
                for (let r = BRICK_ROW_COUNT - 1; r >= 0; r--) {
                    for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                        if (bricks[c] && bricks[c][r] && bricks[c][r].status === 1) {
                            lowestActiveRow = r; break;
                        }
                    }
                    if (lowestActiveRow !== -1) break;
                }
                const shiftAmount = (lowestActiveRow === -1) ? BRICK_ROW_COUNT : (BRICK_ROW_COUNT - 1) - lowestActiveRow;
                if (shiftAmount > 0) {
                    rowsAdvanced += shiftAmount;
                    isAnimatingRows = true;
                    rowsToShiftAmount = shiftAmount;
                    animationTargetY = shiftAmount * ROW_HEIGHT;
                    animationCurrentY = 0;
                }
            }

            function updateRowAnimation() {
                if (!isAnimatingRows) return;
                // Uses the new ROW_ANIMATION_SPEED
                animationCurrentY += ROW_ANIMATION_SPEED;
                if (animationCurrentY >= animationTargetY) {
                    animationCurrentY = animationTargetY; // Clamp
                    // Perform Data Shift
                    for (let r = BRICK_ROW_COUNT - 1; r >= 0 ; r--) {
                        for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                           const targetRow = r + rowsToShiftAmount;
                           if (targetRow < BRICK_ROW_COUNT) {
                                if (bricks[c]) {
                                     bricks[c][targetRow] = bricks[c][r] ? {...bricks[c][r]} : null;
                                     if (bricks[c][targetRow]) {
                                         bricks[c][targetRow].y = targetRow * ROW_HEIGHT + BRICK_OFFSET_TOP;
                                     }
                                }
                           }
                        }
                    }
                    // Generate new bricks
                    for (let r = 0; r < rowsToShiftAmount; r++) {
                        for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                            if (!bricks[c]) bricks[c] = [];
                            bricks[c][r] = createBrick(c, r);
                        }
                    }
                    // Finish Animation
                    isAnimatingRows = false;
                    animationTargetY = 0;
                    animationCurrentY = 0;
                    rowsToShiftAmount = 0;
                }
            }

			function createShatterEffect(x, y, color) { /* ... no changes ... */
				for (let i = 0; i < PARTICLE_COUNT; i++) { particles.push({ x: x, y: y, dx: (Math.random() - 0.5) * PARTICLE_SPEED_FACTOR * 2, dy: (Math.random() - 0.5) * PARTICLE_SPEED_FACTOR * 2, life: PARTICLE_LIFE + Math.random() * 10, color: color, size: PARTICLE_SIZE + Math.random() * 1 }); } }
			function updateParticles() { /* ... no changes ... */
				for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.dx; p.y += p.dy; p.dy += 0.06; p.life--; if (p.life <= 0) particles.splice(i, 1); } }

            function toggleDebugMode() { /* ... no changes ... */
                isDebugMode = !isDebugMode;
                debugSpeedMultiplier = isDebugMode ? 5 : 1;
                console.log("Debug Mode:", isDebugMode ? "ON" : "OFF", "- Speed Multiplier:", debugSpeedMultiplier);
                debugIndicator.style.display = isDebugMode ? 'block' : 'none';
             }

			// --- Input Handlers ---
			function keyDownHandler(e) { /* ... no changes ... */
                if (e.key === "Escape" && !isGameOver) { isPaused = !isPaused; e.preventDefault(); return; }
                if ( (e.code === "Space" || e.key === " ") && isGameOver ) { if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; initGame(); e.preventDefault(); return; }
                if (e.key === 't' || e.key === 'T') { toggleDebugMode(); e.preventDefault(); return; }
				if (!isPaused && !isGameOver && !isAnimatingRows) {
					if (e.key === "Right" || e.key === "ArrowRight" || e.key === "d" || e.key === "D") rightPressed = true;
					else if (e.key === "Left" || e.key === "ArrowLeft" || e.key === "a" || e.key === "A") leftPressed = true;
				}
				if (["ArrowLeft", "ArrowRight", " ", "a", "A", "d", "D", "Escape", "t", "T"].includes(e.key)) e.preventDefault();
			}
			function keyUpHandler(e) { /* ... no changes ... */
				if (e.key === "Right" || e.key === "ArrowRight" || e.key === "d" || e.key === "D") rightPressed = false;
				else if (e.key === "Left" || e.key === "ArrowLeft" || e.key === "a" || e.key === "A") leftPressed = false;
                if (["ArrowLeft", "ArrowRight", "a", "A", "d", "D", "t", "T"].includes(e.key)) e.preventDefault();
			}

            function touchHandler(e) { /* ... no changes ... */
                if (isGameOver) {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null; initGame(); e.preventDefault(); return;
                }
                if (isPaused || isAnimatingRows) return;
                if (e.touches && e.touches.length > 0) {
                    const touchX = e.touches[0].clientX;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const canvasX = (touchX - rect.left) * scaleX;
                    let targetX = canvasX - paddle.width / 2;
                    paddle.x = Math.max(0, Math.min(targetX, canvas.width - paddle.width));
                    e.preventDefault();
                }
            }

			// --- Event Listeners Setup ---
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);
            canvas.addEventListener("touchstart", touchHandler, { passive: false });
            canvas.addEventListener("touchmove", touchHandler, { passive: false });

			// --- Game Loop ---
			function gameLoop() { /* ... no changes ... */
				ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Update State
                updateRowAnimation();
                updateLaunchDelay();
				updatePaddle();
				updateBall();
				const ballCollisionHappened = brickCollision(); // Handles scoring, extra lives, and pass-through
                updateParticles();
                // Check Row Shift Trigger
                if (ballCollisionHappened && !isPaused && !isGameOver && !isAnimatingRows) {
                    checkAndShiftRows();
                }
				// Draw Elements
				drawBricks();
				drawPaddle();
				drawBall();
				drawParticles();
				drawScore();
				drawLives();
                // Draw Overlay Messages
				if (isGameOver) drawMessage("GAME OVER", GAMEOVER_COLOR);
				else if (isPaused) drawPauseMessage();

				animationFrameId = requestAnimationFrame(gameLoop);
			}

			// --- Start Game ---
			initGame();
		</script>
	</body>
</html>